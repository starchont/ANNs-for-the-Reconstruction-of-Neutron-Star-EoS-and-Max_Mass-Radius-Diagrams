import numpy as np
from scipy.integrate import solve_ivp
import warnings
import timeit
import multiprocessing
import numba


warnings.filterwarnings("ignore")


start_time = timeit.default_timer()


# Define the EoSs functions
@numba.jit
def MDI_1(p):
    if p > 0.184:
        E = 4.1844 * pow(p, 0.81449) + 95.00135 * pow(p, 0.31736)
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def MDI_2(p):
    if p > 0.184:
        E = 5.97365 * pow(p, 0.77374) + 89.24 * pow(p, 0.30993)
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def MDI_3(p):
    if p > 0.184:
        E = 15.55 * pow(p, 0.666) + 76.71 * pow(p, 0.247)
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def MDI_4(p):
    if p > 0.184:
        E = 25.99587 * pow(p, 0.61209) + 65.62193 * pow(p, 0.15512)
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def NLD(p):
    if p > 0.184:
        E = 119.05736 + 304.80445 * (1 - np.exp(-p/48.61465)) + 33722.34448 * (1 - np.exp(-p/17499.47411))
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def HHJ_1(p):
    if p > 0.184:
        E = 1.78429 * pow(p, 0.93761) + 106.93652 * pow(p, 0.31715)
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def HHJ_2(p):
    if p > 0.184:
        E = 1.18961 * pow(p, 0.96539) + 108.40302 * pow(p, 0.31264)
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def ska(p):
    if p > 0.184:
        E = 0.53928 * pow(p, 1.01394) + 94.31452 * pow(p, 0.35135)
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def skI4(p):
    if p > 0.184:
        E = 4.75668 * pow(p, 0.76537) + 105.722 * pow(p, 0.2745)
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def HLPS_2(p):
    if p > 0.184:
        E = 172.858 * (1 - np.exp(-p/22.8644)) + 2777.75 * (1 - np.exp(-p/1909.97)) + 161.553
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def HLPS_3(p):
    if p > 0.184:
        E = 131.811 * (1 - np.exp(-p / 4.41577)) + 924.143 * (1 - np.exp(-p / 523.736)) + 81.5682
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def SCVBB(p):
    if p > 0.184:
        E = 0.371414 * pow(p, 1.08004) + 109.258 * pow(p, 0.351019)
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def WFF_1(p):
    if p > 0.184:
        E = 0.00127717 * pow(p, 1.69617) + 135.233 * pow(p, 0.331471)
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def WFF_2(p):
    if p > 0.184:
        E = 0.00244523 * pow(p, 1.62692) + 122.076 * pow(p, 0.340401)
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def PS(p):
    if p > 0.184:
        E = 9805.95 * (1 - np.exp(-0.000193624 * p)) + 212.072 * (1 - np.exp(-0.401508 * p)) + 1.69483
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def W(p):
    if p > 0.184:
        E = 0.261822 * pow(p, 1.16851) + 92.4893 * pow(p, 0.307728)
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def BGP(p):
    if p > 0.184:
        E = 0.0112475 * pow(p, 1.59689) + 102.302 * pow(p, 0.335526)
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def BL_1(p):
    if p > 0.184:
        E = 0.488686 * pow(p, 1.01457) + 102.26 * pow(p, 0.355095)
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def BL_2(p):
    if p > 0.184:
        E = 1.34241 * pow(p, 0.910079) + 100.756 * pow(p, 0.354129)
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def DH(p):
    if p > 0.184:
        E = 39.5021 * pow(p, 0.541485) + 96.0528 * pow(p, 0.00401285)
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


@numba.jit
def APR_1(p):
    if p > 0.184:
        E = 0.000719964 * pow(p, 1.85898) + 108.975 * pow(p, 0.340074)
    elif 0.184 >= p > 9.34375 * 10**-5:
        E = 0.00873 + 103.17338*(1-np.exp(-p/0.38527)) + 7.34979*(1-np.exp(-p/0.01211))
    elif 9.34375 * 10**-5 >= p > 4.1725 * 10**-8:
        E = 0.00015 + 0.00203 * (1 - np.exp(-p * 344827.5)) + 0.10851 * (1-np.exp(-p * 7692.3076))
    elif 4.1725 * 10**-8 >= p > 1.44875 * 10**(-11):
        E = 0.0000051 * (1-np.exp(-p * 0.2373 * 10**10)) + 0.00014 * (1 - np.exp(-p * 0.4020 * 10**8))
    else:
        E = pow(10, 31.93753+10.82611*np.log10(p)+1.29312*np.log10(p)**2+0.08014*np.log10(p)**3+0.00242*np.log10(p)**4+0.000028*np.log10(p)**5)
    return E


# Define the derivative functions
@numba.jit
def tov(r, y, eos):
    p = y[1]
    mass = y[0]
    E = eos(p)
    dm_dr = 11.2 * pow(10, -6) * pow(r, 2) * E
    dp_dr = -1.474 * ((mass * E)/pow(r, 2)) * (1 + p/E) * (1 + 11.2 * pow(10, -6) * p/mass * pow(r, 3)) * pow((1-2.948 * mass/r), -1)
    df_dr = [dm_dr, dp_dr]
    return df_dr


@numba.jit
def tov_solver(func):
    ic_mass: np.ndarray = np.arange(0.5, 10, 0.1)
    ic_press: np.ndarray = np.arange(5, 1000, 1)
    ic_total: np.ndarray = np.concatenate((ic_mass, ic_press), axis=None)
    array_for_total_results: np.ndarray = np.zeros((len(ic_total), 5))
    print(len(ic_total))
    j: int = 0
    for i in ic_total:
        p_0: float = 1
        init_val: np.ndarray = [10**-12, i]
        r_min: float = 0.00000001
        r_max: float = 0.01
        M: np.ndarray = np.array([])
        P: np.ndarray = np.array([])
        R: np.ndarray = np.array([])
        # E = np.array([])
        z_old: np.ndarray = np.array([])
        while p_0 > 10**-12:
            sol = solve_ivp(tov, (r_min, r_max), init_val, method='LSODA', atol=10**-12, rtol=10**-8, args=(func,))
            z_old = init_val[1]
            init_val[0] = sol.y[0][-1]
            init_val[1] = sol.y[1][-1]
            if init_val[0] < 0:
                break
            if z_old == init_val[1]:
                break
            r_min = sol.t[-1]
            r_max = r_min + 0.001
            p_0 = init_val[1]
            M = np.append(M, sol.y[0])
            R = np.append(R, sol.t)
            P = np.append(P, sol.y[1])
        array_for_total_results[j] = [min(P), i, func(i), max(M), R[-1]]
        j = j + 1
        print("\n", j)
        filename = f"{func.__name__}.txt"
        headers = "P, Pc, E, M, R"
        np.savetxt(filename, array_for_total_results, header=headers)
    return array_for_total_results


if __name__ == '__main__':
    Eos_functions: np.ndarray = [NLD]
    # other = [skI4, HLPS_2, HLPS_3, WFF_1, WFF_2, DH, NLD]
    # eos_done = [MDI_1, MDI_2, MDI_3, MDI_4, HHJ_1, HHJ_2, ska, SCVBB, PS, W, BGP, BL_1, BL_2, APR_1]
    # get the number of available CPU cores
    num_processes: int = multiprocessing.cpu_count()

    # create the multiprocessing pool with the desired number of processes
    pool = multiprocessing.Pool(processes=num_processes)

    # Use the map function to apply tov_solver to each eos in parallel
    pool.map(tov_solver, Eos_functions)

    pool.close()
    pool.join()

    end_time = timeit.default_timer()

    elapsed_time = end_time - start_time

    print("Elapsed time: ", elapsed_time, "seconds")
